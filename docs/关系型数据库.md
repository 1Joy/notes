# 数据库

##定义：

- 狭义：存储数据的仓库

- 广义：可以对数据进行存储和管理的软件，以及数据本身，统称为数据库

数据库是由表，关系，操作组成

### 为什么需要数据库：

- 几乎所有的应用软件都需要数据库来存储shujuk 数据
- 数据库存储数据占用空间小，容易持久保存
- 存储安全
- 容易维护和升级，数据库移植比较容易

###什么是连接：

- 从客户端管理界面创建连接来操控我们在远端或者本地后台运行的数据库

###什么是表间关系：

- 定义：表与表之间的关系

- 实现方式：通过设置不同形式的外键来体现表和表之间不不同关系

- 分类：

  - 一对一：一个事物的主键可以充当另一个事物的外键

  - 一对多：把一的事物的主键作为多的事物的外键(如：部门的主键作为员工的外键)

  - 多对多：

    多对多关系必须添加一个映射表来表示事物与事物的多对多关系(如：班级和老师之间的关系)

###数据库是如何存储数据的：

- 字段：一个事物的某一个特征

- 记录/元组：字段的组合，表示的是一个具体的事物

- 表(表名一般为单数)：记录的集合，表示同一类型事物的集合

- 约束：对一个表中的属性操作的限制

  - 主键

    事物的一个属性或者多个属性的组合，通过这个唯一的属性来辨别这个事物和其他的事物

    主键约束/实体完整性：不允许重复元素，避免数据的冗余

  - 外键

    一个事物的若干属性属于另外若干事物的主键或唯一键 ，描述事物与事物的关系

    外键不一定是来自另外的表，也可能是来自同一个表的主键

    外键约束/引用完整性：从语法上保证了事物所关联的其他事物一定是存在的

  - 唯一键

    唯一约束：保证了事物属性的取值不允许重复，但允许为空。可以唯一地标识关系或表中的单个元组。与主键不同，一个表可以有多个唯一键。唯一键约束只能接受列的一个空值；想对非主键的列和列组实施唯一约束时，可以使用它
  
  - 在SQL Server里面只允许有且只有一行的数据的唯一键列为空
  
- 在Oracle里面允许多行的唯一键列为空
  
- 非空
  
  要求必须为属性赋值
  
- check
  
  约束范围，保证数据的合理性
  
  check约束：保证事物属性的取值在合法的范围之内
  
- default
  
    default约束：保证事物的属性一定会有一个默认值；如果不想对默认值赋值时，需要在赋值的时候指定要赋值的列
  
  - 触发器
  
  - **表和约束的区别**：
  
    数据库是通过表来解决事物的存储问题
  
    数据库是通过约束来解决事物取值的有效性和合法性问题
  
    建表的过程就是指定事物属性及其事物属性的约束的过程

###数据库是如何操作数据的：

- insert
- update
- delete
- T-SQL
- 存储过程
- 函数
- 触发器

### 查询：

- distinct：去重

  select distinct comn,depno from emp：会把comn和depno的组合去重

  select depno,distinct comn from emp：会报错，

- between：查询介于between ... and ...之间的数据

  select * from emp where sal between 1500 and 3000

  select * from emp where sal not between 1500 and 3000

- in：等于某些独立的值

- top：

  select top 5

- null：

  0和null是不同的，null表示没有值，0表示一个确定的值；任何类型都允许数据为null；

  任何数字与Null进行运算结果都为null

  null可以参与如下运算：is， not is

  isnull(comn,0)：函数功能为如果comn如果是null,就返回0

- order by：**某个字段**默认升序(asc)排序；desc：降序

- like：模糊查询

  通配符：

  - %：表示匹配任意0个或者多个字符

  - _：表示匹配任意单个字符

  - [a-f]：表示匹配a到f中的任意一个字符

  - [a,f]：表示匹配a或f字符

  - [^a-f]：表示匹配不是a到f的任意一个字符

  匹配通配符：

  select * from emp where name like '%\\_%'  escape '\\'

  

- 聚合函数：

  单行函数：lower()，upper()

  多行函数：sum()，max()，min()，count()

- group by：分组

  分组之后select子句中只能出现分组后的整体信息，不能出现组内具体信息

- having：对分组之后的信息进行过滤

  1. having子句是用来对分组之后的数据进行过滤；因此使用having时通常都会先使用group by
  2. 如果没有使用group by，但是使用了having子句，意味着把表中的所有数据当作一组来处理
  3. having子句出现的字段必须是分组字段或者聚合函数

  having和where的异同：

  - 相同：都是对数据进行过滤，只保留有效的数据

  - 不同：where是对原始数据的记录过滤，having是对分组之后的数据进行过滤；

    where必须写在having的前面

- 连接查询

  将两个或两个以上的表使用一定的连接条件连接起来，从中查询出满足条件的结果。

  join：连接

  on：连接条件，且有join就必须有on

  - 内连接

    1. select ... from A,B的用法：

       A的每一行与B的每一行进行合并成一条记录

       结果是一个笛卡尔积：行数=A行数*B行数；列数=A列数+B列数

    2. select ... from A,B where ...的用法：

       对[1]产生的笛卡尔积进行过滤

    3. select ... from A join B on ... 的用法：

  - 外连接

    不但返回满足连接条件的记录，而且会返回部分不满足条件的记录

    1. 左外连接

       左表的每一行记录分别和右表的所有行记录进行连接，输出连接条件相等的行；如果右表没有匹配的行，就会只输出一行记录(**改行里面包含了左表一行的记录，右表的全部输出null**)

       **左连接产生的结果行数可能会大于左连接左表的行数**

    2. 右外连接

  - 完全连接

    full  join

    结果集中包含3部分内容：

    1. 两个表匹配的所有记录
    2. 左表中在右表中找不到的记录，右表位置null
    3. 右表中在左表中匹配不到的记录，左表位置为null

  - 交叉连接

    cross join

    产生的结果是一个笛卡尔集

  - 自连接

    一张表自己和自己连接

  - 联合

    union

    1. 联合的若干个select子句输出的列数必须是相等的
    2. 联合的若干个select子句每一列输出的列的类型是兼容的

- 分页查询
- 嵌套查询(子查询)

## 视图

- 为什么要用视图

  简化查询：避免了代码的冗余；避免了书写大量重复的sql语句

- 定义

  代码上可以看作一个select语句；逻辑上可以看作一个**虚拟表**来看

- 使用

  创建视图：

  **注：**

  1. select语句前面不能添加begin;后面不能添加end；
  2. select语句必须为所有输出的计算列(使用函数得出的结果)指定别名

  2. 创建视图时报错'CREATE VIEW'必须是批处理中仅有的语句的解决方案：

     CREATE VIEW语句有一个条件，即该语句必须是第一个被执行的，而在该图中有一个use xsgl，
     --所以系统提示错误。解决方法是：在CREATE VIEW语句的上方和下方加一个GO指令即可

  ```
  create view [视图名字] as
  	select语句
  
  go
  create view [emp_age] as select emp_id,emp_name from emp where emp_age=20;
  go
  
  select * from emp_age
  ```

- 视图优点

  简化查询

  增加数据的保密性（可以将某些表的一些属性隐藏）

- 视图缺点

  增加了数据库的维护成本(因为比如删除了视图相关联的表，但视图不会被删除；或者删除了表里面的某些属性，但视图不知道)

  视图只是简化了查询语句，但并不能加快查询的速度

## 存储过程

## 游标



## 事务

- 为什么要用事务

  事务主要是用来保证数据的合理性和并发处理的能力。即：

  1. 事务可以保证避免数据处于一种不合理的中间状态（一部分成功一部分失败）
  2. 利用事务可以实现多个用户对共享资源的同时访问（并发时访问不出错）

- 事务的三种运行模式：

  1. 自动提交事务：每一条单独的语句都是一个事务，成功则提交；失败则回滚。
  2. 显示事务：每个事务均以begin transaction语句显示的开启事务；以commit或者rollback语句显示的结束事务。
  3. 隐式事务：在前一个事务完成时新事务隐式启动，但每个事务仍以commit或者rollback语句结束事务。

- 事务的特性：

  1. 原子性（A）：事务是一个完整的操作，不可分；要么成功，要么失败。
  2. 一致性（C）：当事务完成时，数据必须处于一致状态，要么处于事务开始时的状态，要么处于事务结束时的状态。
  3. 隔离性（I）：当前事务与其他未完成的事务是隔离的。
  4. 持久性（D）：事务完成后，它对数据库的修改被永久保存，事务日志能够保持事务的永久性

- 

## 索引

- 索引是什么
  
  索引是帮助数据库快速查找数据的**数据结构**
  
  除数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。
  
  一般索引本身比较大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。
  
  ![avatar](.\imgs\index.png)
  
- 为什么要用索引

  - 优势：

    1. 提高数据检索的效率，降低了数据库的IO成本

    2. 通过索引列对数据进行排序，降低了数据排序的成本，降低了CPU的消耗

  - 劣势：

    1. 索引实际上也是一张表，保存了主键与索引字段并指向实体表的记录，所以索引列也要占空间
    2. 虽然索引提高了查询的速度，同时会降低更新表的速度，因为在更新表时索引也会进行调整和更新

- 索引的分类
  
  聚集索引：数据的存储方式和索引的排列物理顺序一致，**每一个表只能有一个聚集索引**
  
  非聚集索引：索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引
  
  区别：
  
  - 聚集索引和非聚集索引的区别是在物理数据的存储方式上。
  
  - 使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置
  - 非聚集索引在查询的时候可避免二次查询，提高性能
  
- 索引的设计原则

  1. 索引不是越多越好，一个表中如有大量的索引，不仅占用磁盘控件还会影响insert、delete、update等语句的性能，因为数据发生更改时，索引也会进行调整和更新
  2. 避免对经常更新的表进行过多的索引
  3. 对于经常用于查询的字段应该创建索引，但是在条件表达式中经常用到的字段如果不同的值类型不多(比如：性别)，这种就没有必要建立索引
  4. 数据量小的表最好不要使用索引，因为数据较少，查询用的事件可能比遍历索引的时间还短，索引可能不会产生优化的效果
  5. 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引能够确保定义列的数据完整性，提高查询速度
  6. 在经常进行分组或排序的列建立索引，如果待分组或排序的列有很多，可以建立组合索引

- 索引的创建和使用

  sql server:

  ```
  -- 创建非聚集索引
  create nonclustered  index index_dept_name
  on dept(dpet_name)
  with fillfactor=30;
  
  
  -- 如何使用索引
  SELECT * FROM 表名
  WITH (INDEX =索引名称) -- 指定索引
  WHERE 查询条件
  ```

  

- 索引的优化

- 

# mysql

```
-- 重新定义结束符，用$$表示结束
delimiter $$
end $$
```



## 索引

### 索引创建和使用

```
-- 创建
create index my_index_name on table(列，[列1，列2])

alter table tablename add index my_index_name (列);

-- 删除
drop index my_index_name on tablename
```



### 索引分类

1. 单值索引

   一个索引只包含单个列，一个表可以有多个单值索引

2. 唯一索引

   索引列为唯一列

3. 主键（聚集）索引

   数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引

4. 非聚集索引

   索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引

### 索引结构

1. BTree索引

   检索原理：真实的数据存在于叶子节点里面，非叶子节点不存储真实数据，只存储指引搜索方向的数据项；每个节点保存的关键字的个数和路数关系为：关键字个数 = 路数 – 1

   ![avatar](.\imgs\mysql-btree.png)查找顺序：比如查找29，在磁盘块1处，将29于17和35比较，<17走左边P1，>17同时<35走中间P2，>35走右边P3。由此走到了磁盘3，再按照比较顺序找到磁盘块8，找到29。

   > 如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO

2. B+Tree（Innodb存储引擎使用）

    检索原理：采用的是左闭合区间，路数和关键个数关系为1比1

   ![avatar](.\imgs\mysql-b+tree.png)

   > 查找规则：查找x=1：
   >
   > 1. 取出根磁盘块，加载1，28，66三个关键字。
   > 2. X <= 1 走P1，取出磁盘块，加载1，10，20三个关键字。
   > 3. X <= 1 走P1，取出磁盘块，加载1，8，9三个关键字。
   > 4. 已经到达叶子节点，命中1，接下来加载对应的数据，图中数据区中存储的是具体的数据。

 **B Tree和B+Tree的区别：**

 1. B+Tree关键字的搜索是采用左闭合区间，之所以采用这种方式是为了支持自增ID
 2. B+Tree根节点和枝干节点没有数据区，关键字对应的数据保存在叶子节点中
 3. 在B+Tree中，叶子节点不会保存子节点的引用
 4. B+Tree叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系

### 索引优化

- 索引失效原因：
  1. 使用索引时没有按照建索引的顺序使用(不满足最佳左前缀原则：**使用索引时按照索引建立的顺序使用，并且不能跳过中间的索引**)；如果是用and连接的条件，即使使用的条件不是索引建立的顺序也会使用到索引，因为mysql内部会做优化调整顺序。
  
  2. 在索引列上进行计算、使用函数、类型转换等操作，会引起索引失效从而进行全表扫描
  
  3. 条件范围之后的索引失效
  
  4. 大量使用了select * 语句；应尽量使用覆盖索引
  
  5.  使用不等于，is null，is not null会引起索引失效
  
  6. like 以通配符开头（如：‘%joy%’）等会引起索引失效
  
     通过查询出来的字段是覆盖索引可以避免 ‘%joy%’引起的索引失效
  
  7. 字符串类型不加单引号会引起索引失效
  
     字符串不加单引号会在内部进行一个类型转化
  
  8. 使用or连接条件是引起索引失效
- 



##  explain（查看执行计划）

### explain的使用

explain+sql语句

### explain的作用

1. 表的读取和加载顺序
2. 数据读取操作的操作类型(select_type)
3. 查看哪些索引可以使用，哪些索引被实际使用
4. 表之间的引用

### explain的字段含义

1. id：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序

   - id相同，执行顺序从上到下

     按顺序执行select子句

   - id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行

   - id相同于不相同的情况同时存在，先执行序号大的，再按从上到下的顺序执行id相同的

2. select_type：查询的类型，主要用于区别普通查询，联合查询，子查询等复杂查询

   - simple：简单的select查询，查询中不包含子查询或者union
   - primary：查询中若包含任何复杂的子部分，最外层查询被标记为哦primary
   - subquery：在select或者where列表中包含了子查询
   - derived：在from列表中包含的子查询被标记为derived(衍生)，MySQL会递归这姓这些子查询，结果放在临时表中
   - union
   - union result

3. table：数据关于哪个表

4. type：查询使用了什么类型

   好->差：system>const>eq_ref>ref>range>index>all

   - system：表只有一行记录(等于系统表)，这是const类型的特例，可忽略
   - const：表示通过索引一次就找到了，const用于比较primary key和unique索引。比如将where根据主键查找
   - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录匹配，常见于主键或唯一索引扫描
   - ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，但是它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体
   - range：只检索给定范围的行，使用一个索引来选择行，一般指的是在where子句后出现的范围查询；这种范围扫描要比全表扫描好
   - index：只遍历索引树，常也叫做全表扫描
   - all：全表扫描，

5. possible_keys：显示可能应用在表中的索引（一个或多个）；查询涉及到的字段上若存在索引，则该索引会被列出，但部一定会被使用

6. key：实际使用到的索引，如果是NULL，表示没有用到索引；如果使用了覆盖索引（select后查询出的字段，与建立复合索引的个数、顺序一致），则该索引仅出现在key列表中

7. key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好；

   显示的值为索引字段最大可能的长度，而不是实际使用的长度，即key_len是根据表定义计算得到，而不是表内检索得到的

8. ref：显示索引的拿一列被使用了，如果可能的话，最好是一个常数（查询条件是一个常量），

9. rows：估算出找到查询结果大致要查找多少行记录，值越小越好

10. extra：

   - using filesort(文件内排序)：mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法用索引完成的排序叫文件内排序

   - using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表；常见于排序或分组查询

   - using index：表示相应的select操作中使用了覆盖索引，避免了访问表的数据行；

     如果同时出现using where，表明索引被用来执行索引键值的查找；

     如果没有同时出现 using where，表明索引用来读取数据而非执行查找动作

   - using where：使用了where查询

   - using join buffer：使用了连接缓存

   - impossible where：where子句总是返回false

   - select tables optimized away：没有进行分组的情况下，对数据使用了多行的聚合函数

   - distinct：去重

## 查询优化

**小表驱动大表**

### exists

- 说明：将主查询里面的数据，放到子查询里面做条件判断，如果相等返回true,这条主查询的数据就会被查询出来；否则就不会被查询出来

- 用法：select * from table where exists (subquery)

- 注：

  exists (subquery)只会返回true或者false两个值，因此子查询里面的select * 语句可以替换为任意select子句，因为MySQL在执行时会忽略select子句

  当主查询里面的表的数据小于子查询表里面的数据条数时，exists的性能优于in的性能

### in

- 用法：select * from table where id in (subquery)

- 注：

  在主查询中会用到子查询中select子句中查询的结果

  当子查询中表的数据条数小于主查询中表的数据条数时，in的性能优于exists性能

###  排序优化

mysql支持两种方式的排序：

- fileSort：指MySQL扫描索引本身完成排序。效率比较低

  1. 双路排序算法

     两次扫描磁盘（I\O耗时），最终得到数据，读取行指针和orderby列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新在列表中读取对应的数据输出

  2. 单路排序算法

     从磁盘读取查询需要的所有列，按照orderby列在buffer中对数据进行排序，然后扫描排序后的列进行输出。这种方式效率更快些，避免了二次读取数据，并且把随机IO变成了顺序IO，但是会使用更多的内存空间（因为把数据都保存在了内存里面）

     单路排序可能存在的问题：

     取出来的数据大小超过了sort_buffer的容量大小，会造成分批次去取buffer大小的数据进行排序，从而会进行多次IO

  3. 

- index：

  order by子句使用到了索引最左前列会使用index排序

  使用where子句与order by子句条件列组合满足索引最左前列会使用index排序

### 分组优化

group by实质是先排序后进行分组，遵照索引建的最佳左前缀

where效率高于having

## 慢查询日志

慢查询：sql执行时间超过了long_query_time（默认10秒）

慢查询日志：用来记录超过时间的sql的日志

## show profile

用来分析当前会话中语句执行的资源消耗情况，可以用于SQL的调优的测量。保存最近15次的运行结果

## 锁

### 锁的分类

- 从对数据操作的类型分

  - 读锁（共享锁）：同一份数据，多个读操作可以同时进行
  - 写锁（排它锁）：当写操作没有完成前，会阻断其他的读和写操作

- 从对数据操作的粒度分

  - 表锁（偏读）

    特点：MyISAM存储引擎，开销小，加锁快；没有死锁，锁的粒度大，发生锁冲突的概率大，并大度低

    操作：

    1. 查看锁：show open tables

    2. 加锁：

       - 加读锁：lock table 表名字 read,表名字 read

         如果会话A给某一个表加了读锁，那么A不能对这个表进行更新，且不能读取其他表的数据；但是不会影响其他会话对其他表的读写操作，对于会话A锁住的表的更新会进入阻塞(此时在等待锁的释放)

       - 加写锁：lock table 表名字 write

         如果会话A给某一个表加了写锁，那么会话A可对这个表进行读写操作，但是不能去写其他的表；其他会话不能对锁住的表进行读写操作(阻塞，等待锁释放)，但是不会影响对于其他表的操作

    3. 释放锁：unlock tables

  - 行锁（偏写）

    特点：InnoDB存储引擎，开销大，加锁慢；会出现死锁，锁粒度小，发生锁冲突的概率小，并发度高；对索引加锁；

    InnoDB和MyISAM的不同在于：一是支持事务，二是使用了行锁

    没有索引行锁会被升级成表锁

    间隙锁：当用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引加锁；对于在条件范围内但是不存在的数据记录叫做间隙；InnoDB也会对这个间隙加锁，叫做间隙锁；可避免幻读

    操作：

    1. 为某条记录加锁：

       sql语句 + for update

       commit提交之后释放锁


## 主从复制

复制的步骤：

1. master将改变记录到二进制日志(binary log)，这些记录过程叫做二进制日志事件(binary log events)
2. slave将master的binary log events拷贝到自己的中继日志(relay log)
3. slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制时异步的串行化的







# 1





