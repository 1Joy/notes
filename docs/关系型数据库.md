# 数据库

##定义：

- 狭义：存储数据的仓库

- 广义：可以对数据进行存储和管理的软件，以及数据本身，统称为数据库

数据库是由表，关系，操作组成

### 为什么需要数据库：

- 几乎所有的应用软件都需要数据库来存储shujuk 数据
- 数据库存储数据占用空间小，容易持久保存
- 存储安全
- 容易维护和升级，数据库移植比较容易

###什么是连接：

- 从客户端管理界面创建连接来操控我们在远端或者本地后台运行的数据库

###什么是表间关系：

- 定义：表与表之间的关系

- 实现方式：通过设置不同形式的外键来体现表和表之间不不同关系

- 分类：

  - 一对一：一个事物的主键可以充当另一个事物的外键

  - 一对多：把一的事物的主键作为多的事物的外键(如：部门的主键作为员工的外键)

  - 多对多：

    多对多关系必须添加一个映射表来表示事物与事物的多对多关系(如：班级和老师之间的关系)

###数据库是如何存储数据的：

- 字段：一个事物的某一个特征

- 记录/元组：字段的组合，表示的是一个具体的事物

- 表(表名一般为单数)：记录的集合，表示同一类型事物的集合

- 约束：对一个表中的属性操作的限制

  - 主键

    事物的一个属性或者多个属性的组合，通过这个唯一的属性来辨别这个事物和其他的事物

    主键约束/实体完整性：不允许重复元素，避免数据的冗余

  - 外键

    一个事物的若干属性属于另外若干事物的主键或唯一键 ，描述事物与事物的关系

    外键不一定是来自另外的表，也可能是来自同一个表的主键

    外键约束/引用完整性：从语法上保证了事物所关联的其他事物一定是存在的

  - 唯一键

    唯一约束：保证了事物属性的取值不允许重复，但允许为空。可以唯一地标识关系或表中的单个元组。与主键不同，一个表可以有多个唯一键。唯一键约束只能接受列的一个空值；想对非主键的列和列组实施唯一约束时，可以使用它
  
  - 在SQL Server里面只允许有且只有一行的数据的唯一键列为空
  
- 在Oracle里面允许多行的唯一键列为空
  
- 非空
  
  要求必须为属性赋值
  
- check
  
  约束范围，保证数据的合理性
  
  check约束：保证事物属性的取值在合法的范围之内
  
- default
  
    default约束：保证事物的属性一定会有一个默认值；如果不想对默认值赋值时，需要在赋值的时候指定要赋值的列
  
  - 触发器
  
  - **表和约束的区别**：
  
    数据库是通过表来解决事物的存储问题
  
    数据库是通过约束来解决事物取值的有效性和合法性问题
  
    建表的过程就是指定事物属性及其事物属性的约束的过程

###数据库是如何操作数据的：

- insert
- update
- delete
- T-SQL
- 存储过程
- 函数
- 触发器

### 查询：

- distinct：去重

  select distinct comn,depno from emp：会把comn和depno的组合去重

  select depno,distinct comn from emp：会报错，

- between：查询介于between ... and ...之间的数据

  select * from emp where sal between 1500 and 3000

  select * from emp where sal not between 1500 and 3000

- in：等于某些独立的值

- top：

  select top 5

- null：

  0和null是不同的，null表示没有值，0表示一个确定的值；任何类型都允许数据为null；

  任何数字与Null进行运算结果都为null

  null可以参与如下运算：is， not is

  isnull(comn,0)：函数功能为如果comn如果是null,就返回0

- order by：**某个字段**默认升序(asc)排序；desc：降序

- like：模糊查询

  通配符：

  - %：表示匹配任意0个或者多个字符

  - _：表示匹配任意单个字符

  - [a-f]：表示匹配a到f中的任意一个字符

  - [a,f]：表示匹配a或f字符

  - [^a-f]：表示匹配不是a到f的任意一个字符

  匹配通配符：

  select * from emp where name like '%\\_%'  escape '\\'

  

- 聚合函数：

  单行函数：lower()，upper()

  多行函数：sum()，max()，min()，count()

- group by：分组

  分组之后select子句中只能出现分组后的整体信息，不能出现组内具体信息

- having：对分组之后的信息进行过滤

  1. having子句是用来对分组之后的数据进行过滤；因此使用having时通常都会先使用group by
  2. 如果没有使用group by，但是使用了having子句，意味着把表中的所有数据当作一组来处理
  3. having子句出现的字段必须是分组字段或者聚合函数

  having和where的异同：

  - 相同：都是对数据进行过滤，只保留有效的数据

  - 不同：where是对原始数据的记录过滤，having是对分组之后的数据进行过滤；

    where必须写在having的前面

- 连接查询

  将两个或两个以上的表使用一定的连接条件连接起来，从中查询出满足条件的结果。

  join：连接

  on：连接条件，且有join就必须有on

  - 内连接

    1. select ... from A,B的用法：

       A的每一行与B的每一行进行合并成一条记录

       结果是一个笛卡尔积：行数=A行数*B行数；列数=A列数+B列数

    2. select ... from A,B where ...的用法：

       对[1]产生的笛卡尔积进行过滤

    3. select ... from A join B on ... 的用法：

  - 外连接

    不但返回满足连接条件的记录，而且会返回部分不满足条件的记录

    1. 左外连接

       左表的每一行记录分别和右表的所有行记录进行连接，输出连接条件相等的行；如果右表没有匹配的行，就会只输出一行记录(**改行里面包含了左表一行的记录，右表的全部输出null**)

       **左连接产生的结果行数可能会大于左连接左表的行数**

    2. 右外连接

  - 完全连接

    full  join

    结果集中包含3部分内容：

    1. 两个表匹配的所有记录
    2. 左表中在右表中找不到的记录，右表位置null
    3. 右表中在左表中匹配不到的记录，左表位置为null

  - 交叉连接

    cross join

    产生的结果是一个笛卡尔集

  - 自连接

    一张表自己和自己连接

  - 联合

    union

    1. 联合的若干个select子句输出的列数必须是相等的
    2. 联合的若干个select子句每一列输出的列的类型是兼容的

- 分页查询
- 嵌套查询(子查询)

## 视图

- 为什么要用视图

  简化查询：避免了代码的冗余；避免了书写大量重复的sql语句

- 定义

  代码上可以看作一个select语句；逻辑上可以看作一个**虚拟表**来看

- 使用

  创建视图：

  **注：**

  1. select语句前面不能添加begin;后面不能添加end；
  2. select语句必须为所有输出的计算列(使用函数得出的结果)指定别名

  2. 创建视图时报错'CREATE VIEW'必须是批处理中仅有的语句的解决方案：

     CREATE VIEW语句有一个条件，即该语句必须是第一个被执行的，而在该图中有一个use xsgl，
     --所以系统提示错误。解决方法是：在CREATE VIEW语句的上方和下方加一个GO指令即可

  ```
  create view [视图名字] as
  	select语句
  
  go
  create view [emp_age] as select emp_id,emp_name from emp where emp_age=20;
  go
  
  select * from emp_age
  ```

- 视图优点

  简化查询

  增加数据的保密性（可以将某些表的一些属性隐藏）

- 视图缺点

  增加了数据库的维护成本(因为比如删除了视图相关联的表，但视图不会被删除；或者删除了表里面的某些属性，但视图不知道)

  视图只是简化了查询语句，但并不能加快查询的速度

## 存储过程

## 游标



## 事务

- 为什么要用事务

  事务主要是用来保证数据的合理性和并发处理的能力。即：

  1. 事务可以保证避免数据处于一种不合理的中间状态（一部分成功一部分失败）
  2. 利用事务可以实现多个用户对共享资源的同时访问（并发时访问不出错）

- 事务的三种运行模式：

  1. 自动提交事务：每一条单独的语句都是一个事务，成功则提交；失败则回滚。
  2. 显示事务：每个事务均以begin transaction语句显示的开启事务；以commit或者rollback语句显示的结束事务。
  3. 隐式事务：在前一个事务完成时新事务隐式启动，但每个事务仍以commit或者rollback语句结束事务。

- 事务的特性：

  1. 原子性（A）：事务是一个完整的操作，不可分；要么成功，要么失败。
  2. 一致性（C）：当事务完成时，数据必须处于一致状态，要么处于事务开始时的状态，要么处于事务结束时的状态。
  3. 隔离性（I）：当前事务与其他未完成的事务是隔离的。
  4. 持久性（D）：事务完成后，它对数据库的修改被永久保存，事务日志能够保持事务的永久性

- 

## 索引





# 1

